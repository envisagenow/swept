//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.3.1.7705
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.3.1.7705 ..\\..\\DSL\\ChangeRule.g 2011-06-25 06:18:34

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162


#pragma warning disable 3021
using System;


using System.Collections.Generic;
using Antlr.Runtime;

namespace swept.DSL
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.3.1.7705")]
[System.CLSCompliant(false)]
public partial class ChangeRuleParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AND", "CHARACTER_LITERAL", "DECIMAL_LITERAL", "DIFFERENCE", "EscapeSequence", "FILE_LANGUAGE", "FILE_NAME", "IDENTIFIER", "LANGUAGE", "LETTER", "LINES_MATCH", "LINE_COMMENT", "OR", "STRING_BODY_DQ", "STRING_BODY_SQ", "STRING_LITERAL", "WS", "'('", "')'"
	};
	public const int EOF=-1;
	public const int AND=4;
	public const int CHARACTER_LITERAL=5;
	public const int DECIMAL_LITERAL=6;
	public const int DIFFERENCE=7;
	public const int EscapeSequence=8;
	public const int FILE_LANGUAGE=9;
	public const int FILE_NAME=10;
	public const int IDENTIFIER=11;
	public const int LANGUAGE=12;
	public const int LETTER=13;
	public const int LINES_MATCH=14;
	public const int LINE_COMMENT=15;
	public const int OR=16;
	public const int STRING_BODY_DQ=17;
	public const int STRING_BODY_SQ=18;
	public const int STRING_LITERAL=19;
	public const int WS=20;
	public const int T__21=21;
	public const int T__22=22;

	// delegates
	// delegators

	public ChangeRuleParser( ITokenStream input )
		: this( input, new RecognizerSharedState() )
	{
	}
	public ChangeRuleParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
		

	public override string[] TokenNames { get { return ChangeRuleParser.tokenNames; } }
	public override string GrammarFileName { get { return "..\\..\\DSL\\ChangeRule.g"; } }


	private NodeFactory factory = new NodeFactory();


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules

	partial void EnterRule_expression();
	partial void LeaveRule_expression();

	// $ANTLR start "expression"
	// ..\\..\\DSL\\ChangeRule.g:31:8: public expression returns [ISubquery sq] : lhs= and_exp (op= ( OR | DIFFERENCE ) rhs= and_exp )? ;
	[GrammarRule("expression")]
	public ISubquery expression()
	{
		EnterRule_expression();
		EnterRule("expression", 1);
		TraceIn("expression", 1);
		ISubquery sq = default(ISubquery);

		IToken op = default(IToken);
		ISubquery lhs = default(ISubquery);
		ISubquery rhs = default(ISubquery);

		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(31, 1);
		try
		{
			// ..\\..\\DSL\\ChangeRule.g:32:2: (lhs= and_exp (op= ( OR | DIFFERENCE ) rhs= and_exp )? )
			DebugEnterAlt(1);
			// ..\\..\\DSL\\ChangeRule.g:32:4: lhs= and_exp (op= ( OR | DIFFERENCE ) rhs= and_exp )?
			{
			DebugLocation(32, 7);
			PushFollow(Follow._and_exp_in_expression107);
			lhs=and_exp();
			PopFollow();

			DebugLocation(32, 16);
			 sq = lhs; 
			DebugLocation(32, 31);
			// ..\\..\\DSL\\ChangeRule.g:32:31: (op= ( OR | DIFFERENCE ) rhs= and_exp )?
			int alt1=2;
			try { DebugEnterSubRule(1);
			try { DebugEnterDecision(1, false);
			int LA1_0 = input.LA(1);

			if ((LA1_0==DIFFERENCE||LA1_0==OR))
			{
				alt1 = 1;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\DSL\\ChangeRule.g:32:32: op= ( OR | DIFFERENCE ) rhs= and_exp
				{
				DebugLocation(32, 34);
				op=(IToken)input.LT(1);
				if (input.LA(1)==DIFFERENCE||input.LA(1)==OR)
				{
					input.Consume();
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(32, 56);
				PushFollow(Follow._and_exp_in_expression124);
				rhs=and_exp();
				PopFollow();

				DebugLocation(32, 65);
				 sq = factory.Get( lhs, op, rhs ); 

				}
				break;

			}
			} finally { DebugExitSubRule(1); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expression", 1);
			LeaveRule("expression", 1);
			LeaveRule_expression();
		}
		DebugLocation(33, 1);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return sq;

	}
	// $ANTLR end "expression"


	partial void EnterRule_and_exp();
	partial void LeaveRule_and_exp();

	// $ANTLR start "and_exp"
	// ..\\..\\DSL\\ChangeRule.g:36:8: public and_exp returns [ISubquery sq] : lhs= atom (op= AND rhs= atom )? ;
	[GrammarRule("and_exp")]
	public ISubquery and_exp()
	{
		EnterRule_and_exp();
		EnterRule("and_exp", 2);
		TraceIn("and_exp", 2);
		ISubquery sq = default(ISubquery);

		IToken op = default(IToken);
		ISubquery lhs = default(ISubquery);
		ISubquery rhs = default(ISubquery);

		try { DebugEnterRule(GrammarFileName, "and_exp");
		DebugLocation(36, 1);
		try
		{
			// ..\\..\\DSL\\ChangeRule.g:37:2: (lhs= atom (op= AND rhs= atom )? )
			DebugEnterAlt(1);
			// ..\\..\\DSL\\ChangeRule.g:37:4: lhs= atom (op= AND rhs= atom )?
			{
			DebugLocation(37, 7);
			PushFollow(Follow._atom_in_and_exp160);
			lhs=atom();
			PopFollow();

			DebugLocation(37, 13);
			 sq = lhs; 
			DebugLocation(37, 28);
			// ..\\..\\DSL\\ChangeRule.g:37:28: (op= AND rhs= atom )?
			int alt2=2;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, false);
			int LA2_0 = input.LA(1);

			if ((LA2_0==AND))
			{
				alt2 = 1;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\DSL\\ChangeRule.g:37:29: op= AND rhs= atom
				{
				DebugLocation(37, 31);
				op=(IToken)Match(input,AND,Follow._AND_in_and_exp167); 
				DebugLocation(37, 39);
				PushFollow(Follow._atom_in_and_exp171);
				rhs=atom();
				PopFollow();

				DebugLocation(37, 45);
				 sq = factory.Get( lhs, op, rhs ); 

				}
				break;

			}
			} finally { DebugExitSubRule(2); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("and_exp", 2);
			LeaveRule("and_exp", 2);
			LeaveRule_and_exp();
		}
		DebugLocation(38, 1);
		} finally { DebugExitRule(GrammarFileName, "and_exp"); }
		return sq;

	}
	// $ANTLR end "and_exp"


	partial void EnterRule_atom();
	partial void LeaveRule_atom();

	// $ANTLR start "atom"
	// ..\\..\\DSL\\ChangeRule.g:40:8: public atom returns [ISubquery sq] : (q= direct_query | '(' q= expression ')' );
	[GrammarRule("atom")]
	public ISubquery atom()
	{
		EnterRule_atom();
		EnterRule("atom", 3);
		TraceIn("atom", 3);
		ISubquery sq = default(ISubquery);

		ISubquery q = default(ISubquery);

		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(40, 1);
		try
		{
			// ..\\..\\DSL\\ChangeRule.g:41:2: (q= direct_query | '(' q= expression ')' )
			int alt3=2;
			try { DebugEnterDecision(3, false);
			int LA3_0 = input.LA(1);

			if (((LA3_0>=FILE_LANGUAGE && LA3_0<=FILE_NAME)||LA3_0==LINES_MATCH))
			{
				alt3 = 1;
			}
			else if ((LA3_0==21))
			{
				alt3 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 3, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\DSL\\ChangeRule.g:41:4: q= direct_query
				{
				DebugLocation(41, 5);
				PushFollow(Follow._direct_query_in_atom195);
				q=direct_query();
				PopFollow();

				DebugLocation(41, 19);
				 sq = q; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\DSL\\ChangeRule.g:42:4: '(' q= expression ')'
				{
				DebugLocation(42, 4);
				Match(input,21,Follow._21_in_atom202); 
				DebugLocation(42, 9);
				PushFollow(Follow._expression_in_atom206);
				q=expression();
				PopFollow();

				DebugLocation(42, 21);
				Match(input,22,Follow._22_in_atom208); 
				DebugLocation(42, 25);
				 sq = q; 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("atom", 3);
			LeaveRule("atom", 3);
			LeaveRule_atom();
		}
		DebugLocation(43, 1);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return sq;

	}
	// $ANTLR end "atom"


	partial void EnterRule_direct_query();
	partial void LeaveRule_direct_query();

	// $ANTLR start "direct_query"
	// ..\\..\\DSL\\ChangeRule.g:48:8: public direct_query returns [ISubquery sq] : (op= ( FILE_NAME | LINES_MATCH ) regex |op= FILE_LANGUAGE LANGUAGE );
	[GrammarRule("direct_query")]
	public ISubquery direct_query()
	{
		EnterRule_direct_query();
		EnterRule("direct_query", 4);
		TraceIn("direct_query", 4);
		ISubquery sq = default(ISubquery);

		IToken op = default(IToken);
		IToken LANGUAGE2 = default(IToken);
		ChangeRuleParser.regex_return regex1 = default(ChangeRuleParser.regex_return);

		try { DebugEnterRule(GrammarFileName, "direct_query");
		DebugLocation(48, 1);
		try
		{
			// ..\\..\\DSL\\ChangeRule.g:49:2: (op= ( FILE_NAME | LINES_MATCH ) regex |op= FILE_LANGUAGE LANGUAGE )
			int alt4=2;
			try { DebugEnterDecision(4, false);
			int LA4_0 = input.LA(1);

			if ((LA4_0==FILE_NAME||LA4_0==LINES_MATCH))
			{
				alt4 = 1;
			}
			else if ((LA4_0==FILE_LANGUAGE))
			{
				alt4 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 4, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\DSL\\ChangeRule.g:49:4: op= ( FILE_NAME | LINES_MATCH ) regex
				{
				DebugLocation(49, 6);
				op=(IToken)input.LT(1);
				if (input.LA(1)==FILE_NAME||input.LA(1)==LINES_MATCH)
				{
					input.Consume();
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(49, 33);
				PushFollow(Follow._regex_in_direct_query284);
				regex1=regex();
				PopFollow();

				DebugLocation(49, 39);
				 sq = factory.GetQuery( op, (regex1!=null?input.ToString(regex1.Start,regex1.Stop):null) ); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\DSL\\ChangeRule.g:50:4: op= FILE_LANGUAGE LANGUAGE
				{
				DebugLocation(50, 6);
				op=(IToken)Match(input,FILE_LANGUAGE,Follow._FILE_LANGUAGE_in_direct_query293); 
				DebugLocation(50, 21);
				LANGUAGE2=(IToken)Match(input,LANGUAGE,Follow._LANGUAGE_in_direct_query295); 
				DebugLocation(50, 30);
				 sq = factory.GetQuery( op, (LANGUAGE2!=null?LANGUAGE2.Text:null) ); 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("direct_query", 4);
			LeaveRule("direct_query", 4);
			LeaveRule_direct_query();
		}
		DebugLocation(51, 1);
		} finally { DebugExitRule(GrammarFileName, "direct_query"); }
		return sq;

	}
	// $ANTLR end "direct_query"

	private sealed partial class regex_return : ParserRuleReturnScope<IToken>
	{
		public regex_return(ChangeRuleParser grammar) {OnCreated(grammar);}
		partial void OnCreated(ChangeRuleParser grammar);
	}

	partial void EnterRule_regex();
	partial void LeaveRule_regex();

	// $ANTLR start "regex"
	// ..\\..\\DSL\\ChangeRule.g:53:1: regex : STRING_LITERAL ;
	[GrammarRule("regex")]
	private ChangeRuleParser.regex_return regex()
	{
		EnterRule_regex();
		EnterRule("regex", 5);
		TraceIn("regex", 5);
		ChangeRuleParser.regex_return retval = new ChangeRuleParser.regex_return(this);
		retval.Start = (IToken)input.LT(1);

		try { DebugEnterRule(GrammarFileName, "regex");
		DebugLocation(53, 1);
		try
		{
			// ..\\..\\DSL\\ChangeRule.g:54:2: ( STRING_LITERAL )
			DebugEnterAlt(1);
			// ..\\..\\DSL\\ChangeRule.g:54:4: STRING_LITERAL
			{
			DebugLocation(54, 4);
			Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_regex309); 

			}

			retval.Stop = (IToken)input.LT(-1);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("regex", 5);
			LeaveRule("regex", 5);
			LeaveRule_regex();
		}
		DebugLocation(55, 1);
		} finally { DebugExitRule(GrammarFileName, "regex"); }
		return retval;

	}
	// $ANTLR end "regex"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _and_exp_in_expression107 = new BitSet(new ulong[]{0x10082UL});
		public static readonly BitSet _set_in_expression114 = new BitSet(new ulong[]{0x204600UL});
		public static readonly BitSet _and_exp_in_expression124 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _atom_in_and_exp160 = new BitSet(new ulong[]{0x12UL});
		public static readonly BitSet _AND_in_and_exp167 = new BitSet(new ulong[]{0x204600UL});
		public static readonly BitSet _atom_in_and_exp171 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _direct_query_in_atom195 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _21_in_atom202 = new BitSet(new ulong[]{0x204600UL});
		public static readonly BitSet _expression_in_atom206 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _22_in_atom208 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_direct_query276 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _regex_in_direct_query284 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FILE_LANGUAGE_in_direct_query293 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _LANGUAGE_in_direct_query295 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_LITERAL_in_regex309 = new BitSet(new ulong[]{0x2UL});

	}
	#endregion Follow sets
}

} // namespace swept.DSL
