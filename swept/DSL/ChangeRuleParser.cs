//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.3.1.7705
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.3.1.7705 ..\\..\\DSL\\ChangeRule.g 2011-08-02 10:58:46

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162


#pragma warning disable 3021
using System;
using System.Text.RegularExpressions;


using System.Collections.Generic;
using Antlr.Runtime;

namespace swept.DSL
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.3.1.7705")]
[System.CLSCompliant(false)]
public partial class ChangeRuleParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AND", "DECIMAL_LITERAL", "DIFFERENCE", "EscapeSequence", "FILE_LANGUAGE", "FILE_NAME", "LANGUAGE", "LINES_MATCH", "LINE_COMMENT", "OR", "REGEX_MODIFIERS", "STRING_BODY_DQ", "STRING_BODY_RQ", "STRING_BODY_SQ", "STRING_LITERAL", "WS", "'('", "')'"
	};
	public const int EOF=-1;
	public const int AND=4;
	public const int DECIMAL_LITERAL=5;
	public const int DIFFERENCE=6;
	public const int EscapeSequence=7;
	public const int FILE_LANGUAGE=8;
	public const int FILE_NAME=9;
	public const int LANGUAGE=10;
	public const int LINES_MATCH=11;
	public const int LINE_COMMENT=12;
	public const int OR=13;
	public const int REGEX_MODIFIERS=14;
	public const int STRING_BODY_DQ=15;
	public const int STRING_BODY_RQ=16;
	public const int STRING_BODY_SQ=17;
	public const int STRING_LITERAL=18;
	public const int WS=19;
	public const int T__20=20;
	public const int T__21=21;

	// delegates
	// delegators

	public ChangeRuleParser( ITokenStream input )
		: this( input, new RecognizerSharedState() )
	{
	}
	public ChangeRuleParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
		

	public override string[] TokenNames { get { return ChangeRuleParser.tokenNames; } }
	public override string GrammarFileName { get { return "..\\..\\DSL\\ChangeRule.g"; } }


	private NodeFactory factory = new NodeFactory();


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules

	partial void EnterRule_expression();
	partial void LeaveRule_expression();

	// $ANTLR start "expression"
	// ..\\..\\DSL\\ChangeRule.g:31:8: public expression returns [ISubquery sq] : lhs= and_exp (op= ( OR | DIFFERENCE ) rhs= and_exp )* ;
	[GrammarRule("expression")]
	public ISubquery expression()
	{
		EnterRule_expression();
		EnterRule("expression", 1);
		TraceIn("expression", 1);
		ISubquery sq = default(ISubquery);

		IToken op = default(IToken);
		ISubquery lhs = default(ISubquery);
		ISubquery rhs = default(ISubquery);

		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(31, 1);
		try
		{
			// ..\\..\\DSL\\ChangeRule.g:32:2: (lhs= and_exp (op= ( OR | DIFFERENCE ) rhs= and_exp )* )
			DebugEnterAlt(1);
			// ..\\..\\DSL\\ChangeRule.g:32:4: lhs= and_exp (op= ( OR | DIFFERENCE ) rhs= and_exp )*
			{
			DebugLocation(32, 7);
			PushFollow(Follow._and_exp_in_expression109);
			lhs=and_exp();
			PopFollow();

			DebugLocation(32, 16);
			 sq = lhs; 
			DebugLocation(32, 31);
			// ..\\..\\DSL\\ChangeRule.g:32:31: (op= ( OR | DIFFERENCE ) rhs= and_exp )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==DIFFERENCE||LA1_0==OR))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\DSL\\ChangeRule.g:32:32: op= ( OR | DIFFERENCE ) rhs= and_exp
					{
					DebugLocation(32, 34);
					op=(IToken)input.LT(1);
					if (input.LA(1)==DIFFERENCE||input.LA(1)==OR)
					{
						input.Consume();
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(32, 56);
					PushFollow(Follow._and_exp_in_expression126);
					rhs=and_exp();
					PopFollow();

					DebugLocation(32, 65);
					 sq = factory.Get( sq, op, rhs ); 

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expression", 1);
			LeaveRule("expression", 1);
			LeaveRule_expression();
		}
		DebugLocation(33, 1);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return sq;

	}
	// $ANTLR end "expression"


	partial void EnterRule_and_exp();
	partial void LeaveRule_and_exp();

	// $ANTLR start "and_exp"
	// ..\\..\\DSL\\ChangeRule.g:36:8: public and_exp returns [ISubquery sq] : lhs= atom (op= AND rhs= atom )* ;
	[GrammarRule("and_exp")]
	public ISubquery and_exp()
	{
		EnterRule_and_exp();
		EnterRule("and_exp", 2);
		TraceIn("and_exp", 2);
		ISubquery sq = default(ISubquery);

		IToken op = default(IToken);
		ISubquery lhs = default(ISubquery);
		ISubquery rhs = default(ISubquery);

		try { DebugEnterRule(GrammarFileName, "and_exp");
		DebugLocation(36, 1);
		try
		{
			// ..\\..\\DSL\\ChangeRule.g:37:2: (lhs= atom (op= AND rhs= atom )* )
			DebugEnterAlt(1);
			// ..\\..\\DSL\\ChangeRule.g:37:4: lhs= atom (op= AND rhs= atom )*
			{
			DebugLocation(37, 7);
			PushFollow(Follow._atom_in_and_exp162);
			lhs=atom();
			PopFollow();

			DebugLocation(37, 13);
			 sq = lhs; 
			DebugLocation(37, 28);
			// ..\\..\\DSL\\ChangeRule.g:37:28: (op= AND rhs= atom )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_0 = input.LA(1);

				if ((LA2_0==AND))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\DSL\\ChangeRule.g:37:29: op= AND rhs= atom
					{
					DebugLocation(37, 31);
					op=(IToken)Match(input,AND,Follow._AND_in_and_exp169); 
					DebugLocation(37, 39);
					PushFollow(Follow._atom_in_and_exp173);
					rhs=atom();
					PopFollow();

					DebugLocation(37, 45);
					 sq = factory.Get( sq, op, rhs ); 

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("and_exp", 2);
			LeaveRule("and_exp", 2);
			LeaveRule_and_exp();
		}
		DebugLocation(38, 1);
		} finally { DebugExitRule(GrammarFileName, "and_exp"); }
		return sq;

	}
	// $ANTLR end "and_exp"


	partial void EnterRule_atom();
	partial void LeaveRule_atom();

	// $ANTLR start "atom"
	// ..\\..\\DSL\\ChangeRule.g:40:8: public atom returns [ISubquery sq] : (q= query | '(' q= expression ')' );
	[GrammarRule("atom")]
	public ISubquery atom()
	{
		EnterRule_atom();
		EnterRule("atom", 3);
		TraceIn("atom", 3);
		ISubquery sq = default(ISubquery);

		ISubquery q = default(ISubquery);

		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(40, 1);
		try
		{
			// ..\\..\\DSL\\ChangeRule.g:41:2: (q= query | '(' q= expression ')' )
			int alt3=2;
			try { DebugEnterDecision(3, false);
			int LA3_0 = input.LA(1);

			if (((LA3_0>=FILE_LANGUAGE && LA3_0<=FILE_NAME)||LA3_0==LINES_MATCH))
			{
				alt3 = 1;
			}
			else if ((LA3_0==20))
			{
				alt3 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 3, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\DSL\\ChangeRule.g:41:4: q= query
				{
				DebugLocation(41, 5);
				PushFollow(Follow._query_in_atom197);
				q=query();
				PopFollow();

				DebugLocation(41, 12);
				 sq = q; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\DSL\\ChangeRule.g:42:4: '(' q= expression ')'
				{
				DebugLocation(42, 4);
				Match(input,20,Follow._20_in_atom204); 
				DebugLocation(42, 9);
				PushFollow(Follow._expression_in_atom208);
				q=expression();
				PopFollow();

				DebugLocation(42, 21);
				Match(input,21,Follow._21_in_atom210); 
				DebugLocation(42, 25);
				 sq = q; 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("atom", 3);
			LeaveRule("atom", 3);
			LeaveRule_atom();
		}
		DebugLocation(43, 1);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return sq;

	}
	// $ANTLR end "atom"


	partial void EnterRule_query();
	partial void LeaveRule_query();

	// $ANTLR start "query"
	// ..\\..\\DSL\\ChangeRule.g:48:8: public query returns [ISubquery sq] : (op= ( FILE_NAME | LINES_MATCH ) r= regex |op= FILE_LANGUAGE LANGUAGE );
	[GrammarRule("query")]
	public ISubquery query()
	{
		EnterRule_query();
		EnterRule("query", 4);
		TraceIn("query", 4);
		ISubquery sq = default(ISubquery);

		IToken op = default(IToken);
		IToken LANGUAGE1 = default(IToken);
		Regex r = default(Regex);

		try { DebugEnterRule(GrammarFileName, "query");
		DebugLocation(48, 1);
		try
		{
			// ..\\..\\DSL\\ChangeRule.g:49:2: (op= ( FILE_NAME | LINES_MATCH ) r= regex |op= FILE_LANGUAGE LANGUAGE )
			int alt4=2;
			try { DebugEnterDecision(4, false);
			int LA4_0 = input.LA(1);

			if ((LA4_0==FILE_NAME||LA4_0==LINES_MATCH))
			{
				alt4 = 1;
			}
			else if ((LA4_0==FILE_LANGUAGE))
			{
				alt4 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 4, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\DSL\\ChangeRule.g:49:4: op= ( FILE_NAME | LINES_MATCH ) r= regex
				{
				DebugLocation(49, 6);
				op=(IToken)input.LT(1);
				if (input.LA(1)==FILE_NAME||input.LA(1)==LINES_MATCH)
				{
					input.Consume();
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(49, 34);
				PushFollow(Follow._regex_in_query288);
				r=regex();
				PopFollow();

				DebugLocation(49, 41);
				 sq = factory.GetQuery( op, r ); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\DSL\\ChangeRule.g:50:4: op= FILE_LANGUAGE LANGUAGE
				{
				DebugLocation(50, 6);
				op=(IToken)Match(input,FILE_LANGUAGE,Follow._FILE_LANGUAGE_in_query297); 
				DebugLocation(50, 21);
				LANGUAGE1=(IToken)Match(input,LANGUAGE,Follow._LANGUAGE_in_query299); 
				DebugLocation(50, 30);
				 sq = factory.GetQuery( op, (LANGUAGE1!=null?LANGUAGE1.Text:null) ); 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("query", 4);
			LeaveRule("query", 4);
			LeaveRule_query();
		}
		DebugLocation(51, 1);
		} finally { DebugExitRule(GrammarFileName, "query"); }
		return sq;

	}
	// $ANTLR end "query"


	partial void EnterRule_regex();
	partial void LeaveRule_regex();

	// $ANTLR start "regex"
	// ..\\..\\DSL\\ChangeRule.g:53:1: regex returns [Regex rex] : STRING_LITERAL ( REGEX_MODIFIERS )? ;
	[GrammarRule("regex")]
	private Regex regex()
	{
		EnterRule_regex();
		EnterRule("regex", 5);
		TraceIn("regex", 5);
		Regex rex = default(Regex);

		IToken STRING_LITERAL2 = default(IToken);
		IToken REGEX_MODIFIERS3 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "regex");
		DebugLocation(53, 1);
		try
		{
			// ..\\..\\DSL\\ChangeRule.g:54:2: ( STRING_LITERAL ( REGEX_MODIFIERS )? )
			DebugEnterAlt(1);
			// ..\\..\\DSL\\ChangeRule.g:54:4: STRING_LITERAL ( REGEX_MODIFIERS )?
			{
			DebugLocation(54, 4);
			STRING_LITERAL2=(IToken)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_regex317); 
			DebugLocation(54, 19);
			// ..\\..\\DSL\\ChangeRule.g:54:19: ( REGEX_MODIFIERS )?
			int alt5=2;
			try { DebugEnterSubRule(5);
			try { DebugEnterDecision(5, false);
			int LA5_0 = input.LA(1);

			if ((LA5_0==REGEX_MODIFIERS))
			{
				alt5 = 1;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\DSL\\ChangeRule.g:54:19: REGEX_MODIFIERS
				{
				DebugLocation(54, 19);
				REGEX_MODIFIERS3=(IToken)Match(input,REGEX_MODIFIERS,Follow._REGEX_MODIFIERS_in_regex319); 

				}
				break;

			}
			} finally { DebugExitSubRule(5); }

			DebugLocation(54, 36);
			 rex = factory.GetRegex( (STRING_LITERAL2!=null?STRING_LITERAL2.Text:null), (REGEX_MODIFIERS3!=null?REGEX_MODIFIERS3.Text:null) ); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("regex", 5);
			LeaveRule("regex", 5);
			LeaveRule_regex();
		}
		DebugLocation(55, 1);
		} finally { DebugExitRule(GrammarFileName, "regex"); }
		return rex;

	}
	// $ANTLR end "regex"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _and_exp_in_expression109 = new BitSet(new ulong[]{0x2042UL});
		public static readonly BitSet _set_in_expression116 = new BitSet(new ulong[]{0x100B00UL});
		public static readonly BitSet _and_exp_in_expression126 = new BitSet(new ulong[]{0x2042UL});
		public static readonly BitSet _atom_in_and_exp162 = new BitSet(new ulong[]{0x12UL});
		public static readonly BitSet _AND_in_and_exp169 = new BitSet(new ulong[]{0x100B00UL});
		public static readonly BitSet _atom_in_and_exp173 = new BitSet(new ulong[]{0x12UL});
		public static readonly BitSet _query_in_atom197 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _20_in_atom204 = new BitSet(new ulong[]{0x100B00UL});
		public static readonly BitSet _expression_in_atom208 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _21_in_atom210 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_query278 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _regex_in_query288 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FILE_LANGUAGE_in_query297 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _LANGUAGE_in_query299 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_LITERAL_in_regex317 = new BitSet(new ulong[]{0x4002UL});
		public static readonly BitSet _REGEX_MODIFIERS_in_regex319 = new BitSet(new ulong[]{0x2UL});

	}
	#endregion Follow sets
}

} // namespace swept.DSL
